<!DOCTYPE HTML>
<html>
  <head>
    <title>melonJS</title>
    <meta name="description" content="melonJS Tutorial"/>
    <meta name="keywords" content="melonJS, lightweight, HTML5 game engine, HTML5, javascript, canvas, game, engine, framework, tiled, tile, map, loader, parser, TMX, XML, tutorial"/>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="style/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <script type="text/javascript">
      //<![CDATA[

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-13050059-3']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script');
        ga.type = 'text/javascript';
        ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(ga, s);
      })();

      //]]>
    </script>
    <script type="text/javascript" src="SyntaxHighlighter/shCore.js"></script>
    <script type="text/javascript" src="SyntaxHighlighter/shBrushJScript.js"></script>
    <link href="SyntaxHighlighter/shCore.css" rel="stylesheet" type="text/css" />
    <link href="SyntaxHighlighter/shThemeDefault.css" rel="stylesheet" type="text/css" />
    <style type="text/css">
      /*<![CDATA[*/
      pre.c2 {
        font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace;
        color: #000000;
        background-color: #eee;
        font-size: 12px;
        border: 1px dashed #999999;
        line-height: 14px;
        padding: 5px;
        overflow: auto;
        width: 100%
      }

      p.c1 {
        font-weight: bold;
        padding: 0;
      }

      /*]]>*/
    </style>
  </head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <a class="navbar-brand" href="#">
            <img src="https://raw.githubusercontent.com/melonjs/melonJS/master/tasks/jsdoc-template/template/static/images/melon.png" alt="melonJS" height='30'>
          </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <li><a href="http://melonjs.org">Home</a></li>
          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container-fluid -->
    </nav>
    <!-- the "Fork me!" sticker -->

    <div id="main">
      <div class="row">
        <div id="sidebar" class="col-md-2 col-md-offset-1 sidebar">
          <ul class="nav nav-sidebar">
            <li><h3>Content</h3></li>
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#part1">Setting up our ships</a></li>
            <li><a href="#part2">Applying movement</a></li>
          </ul>
        </div>

        <div id="content" class="col-md-8 col-md-offset-3 main">
          <h1>Space Invaders Tutorial</h1>
          <p>In this tutorial, we will create a space invaders clone. As supposed to the <a href="http://melonjs.github.io/tutorial-platformer/">platformer tutorial</a>, which covers Tiled, audio and animation. This tutorial will primarily be focused on creating more game elements through code, and using other APIs that MelonJS provides.</p>

          <!-- INTRO ================================================================== -->
          <div>
            <a id="intro" class="offset-anchor"></a>
            <div class="subcontent">
              <h2>Introduction</h2>
              <p>To work through this tutorial, you need the following:</p>

              <ul>
                <li>
                  The melonJS <a href="https://github.com/melonjs/boilerplate/archive/master.zip">boilerplate</a>, that we will use as default template project for our tutorial.
                </li>
                <li>
                  The tutorial <a href="tutorial_data.zip">image assets</a>, to be uncompressed into the boilerplate data directory. So when you unzip, you should have:
<pre>
data/img/player.png
data/img/ships.png
js/game.js
etc
</pre>
                </li>

                <li>The melonJS <a href="http://www.melonjs.org/download.html"> library</a>. If you downloaded the boilerplate, you will already have this. It should be copied under the /lib directory. You can copy the development version, as the boilerplate provides a minification task.
                </li>

                <li>The melonJS <a href="http://www.melonjs.org/docs/index.html">documentation</a> for more details </li>
              </ul>

              <p>
                <b>Testing/debugging :</b><br/>
                Your best bet is to use a local web server, as for example detailed in the melonJS <a href="https://github.com/melonjs/boilerplate">boilerplate</a> README, by using the `grunt connect` tool, and that will allow you to test your game in your browser using the <a href="http://localhost:8000">http://localhost:8000</a> url.
              </p>
              <p>
                If you just want to use the filesystem, the problem is you'll run into "cross-origin request" security errors. With Chrome, you need to use the "--disable-web-security" parameter or better "--allow-file-access-from-files" when launching the browser. This must be done in order to test any local content, else the browser will complain when trying to load assets through XHR. <strong>Though this method is not recommended.</strong> As long as you have the option enabled, you're adding security vulnerabilities to your session.<br/>
              </p>
            </div>
          </div>

          <!-- Part 1 -->
          <div class="subcontent">
            <a id="part1" class="offset-anchor"></a>
            <h2>Setting up our ships</h2>
            <p>Your directory structure from the boilerplate should look something like this:</p>

<pre>
data/
  img/
    player.png
    ships.png
js/
  game.js
  resources.js
  entities/
    HUD.js
    entities.JS
  screens/
    play.js
    title.js
index.html
index.css
</pre>

            <p>The boilerplate provides us a bunch of default, and for this tutorial there are some we don't need. You can delete the file screens/title.js, and remove the js/entities folder as well. Then update the index.html file to no longer include those. Be sure to remove the references of TitleScreen from the game.js file.</p>

            <pre class="brush: js">
              var game = {

                  // Run on page load.
                  "onload" : function () {
                      // Initialize the video.
                      if (!me.video.init(640, 480, {wrapper : "screen", scale : 'auto'})) {
                          alert("Your browser does not support HTML5 canvas.");
                          return;
                      }

                      // add "#debug" to the URL to enable the debug Panel
                      if (document.location.hash === "#debug") {
                          window.onReady(function () {
                              me.plugin.register.defer(this, me.debug.Panel, "debug", me.input.KEY.V);
                          });
                      }

                      // Initialize the audio.
                      me.audio.init("mp3,ogg");

                      // Set a callback to run when loading is complete.
                      me.loader.onload = this.loaded.bind(this);

                      // Load the resources.
                      me.loader.preload(game.resources);

                      // Initialize melonJS and display a loading screen.
                      me.state.change(me.state.LOADING);
                  },



                  // Run on game resources loaded.
                  "loaded" : function () {
                      // set the "Play/Ingame" Screen Object
                      this.playScreen = new game.PlayScreen();
                      me.state.set(me.state.PLAY, this.playScreen);

                      // start the game
                      me.state.change(me.state.PLAY);
                  }
              };
            </pre>

            <p>Game.js is where the game is bootstrapped. index.html calls the game.onload function after loading all the js files, and doing its own initialization. The <strong>me.video.init</strong> bit creates the canvas tag and gets the video setup.</p><p>Lines 12-16 are for using the debug panel.</p><p>Then we intialize the audio engine, telling it what formats we are supporting for this game.</p>

            <p>We set a callback on <strong>me.loader</strong> to our loaded function, and then tell what assets it needs to load, via an array.</p>

            <p>The final step of this process is setting the state of the game to loading. Game states can be used to for things like menu screen, play screen, pause screen, etc. When changing state, it's important to note that everything is removed from the game world, unless you have it set to be <a href="http://melonjs.github.io/docs/me.Renderable.html#isPersistent" target="_blank">persistent</a> across states.</p>

            <p>The above game object would not get removed from the game world, unless you tell it to explicitly.</p>

            <p>The loaded function then sets up the playscreen and tells the game to use that screen object for the play state. When then change state.</p>

            <h4>Back to space invaders</h4>

            <p>The first thing to add is images to the resources.js file.</p>
            <pre class="brush: js">
              game.resources = [
                { name: "player", type: "image", src: "data/img/player.png" },
                { name: "ships", type: "image", src: "data/img/ships.png" }
              ];
            </pre>
            <p>This variable is the one passed to me.loader.preload in game.js</p>

            <p>The structure for an asset is :</p>
            <table>
              <tr>
                <td>name</td>
                <td>The name of the asset you wish to use in your game. A string key.</td>
              </tr>
              <tr>
                <td>type</td>
                <td>The type of the asset. Valid types are: <strong>audio, binary, image, json, tmx, tsx</strong>. Binary is a good solution for loading raw text, or any other format not listed. TMX & TSX are for tiled file formats. Whether it be the xml or json format.</td>
              </tr>
              <tr>
                <td>src</td>
                <td>The path to the asset, relative from index.html. For audio you need specify the folder instead of direct path.</td>
              </tr>
            </table>

            <p>Open <strong>js/screens/play.js</strong> and empty the code from the two methods: <strong>onResetEvent</strong> and <strong>onDestroyEvent</strong>. Then save, and then open the game in your web browser.</p>

            <p>There is not much to see yet. Let's change that.</p>

            <p>First thing is to create a player entity.</p>

            <p>Add a new file under the js folder, and call it <strong>player.js</strong>. Be sure to add it in the index.html file.</p>

            <pre class="brush: js">
              game.Player = me.Sprite.extend({
                  init: function () {
                      var image = me.loader.getImage("player");
                      this._super(me.Sprite, "init", [me.game.viewport.width / 2 - image.width / 2, me.game.viewport.height - image.height - 20, image]);
                  }
              });
            </pre>
            <p>
              So what we're doing is adding a function to the window.game object that extends <strong>me.Sprite</strong>. It sets up an init method that grabs the player image.</p>
            <p>For the x coordinate, we simply grab the dead center, and subtract half the ship, so it can be positioned in the center. And then set its y property to be 20 pixels above the bottom. Then finally pass the image instance to it. This is the constructor of a sprite. All it expects is an X,Y and an image to be used.
            </p>
            <p>
              Now open up <strong>js/screens/play.js</strong>, and edit the onResetEvent method so it looks like this:
              <pre class="brush: js">
                game.PlayScreen = me.ScreenObject.extend({
                    /**
                     *  action to perform on state change
                     */
                    onResetEvent: function() {
                        me.game.world.addChild(new game.Player());
                    },


                    /**
                     *  action to perform when leaving this screen (state change)
                     */
                    onDestroyEvent: function() {
                    }
                });

              </pre>
            </p>

            <img src="screens/screenone.png" />

            <p>Yay, the ship is on the bottom of the screen!
            </p><p>But we can still see the loading bar, that's not cool. The reason for this is that MelonJS does not want to do any operations that it doesn't have to. Sometimes you'll have a background image that gets redrawn, so it covers the original loading bar. However, we don't have a background image for this game, so what we will do is add a color layer.</p>

            <pre class="brush: js">
              me.game.world.addChild(new me.ColorLayer("background", "#000000", 0));
            </pre>
            <p>
              Add that in the play screen, above the line where we added the player. The first parameter is simply the name for the layer, so it's easy to fetch from the game world later if you need to. The second parameter is simply the color to draw in hex. The last is the z index. We want it to draw first, so we set it at zero. The z-index can also be passed with addChild:
            </p>
            <pre class="brush: js">
              me.game.world.addChild(new me.ColorLayer("background", "#000000"), 0);
            </pre>

            <p>Now the pesky loading bar should be gone. Now let's add in enemies. Create a new file under the js folder called enemy.js, and add it to the index.html file.</p>

            <p>Since enemies will have to collide with things like the player's laser, it should extend <strong>me.Entity</strong>, so lets get that going:</p>
            <pre class="brush: js">
              game.Enemy = me.Entity.extend({
                  init: function (x, y) {
                      this._super(me.Entity, "init", [x, y, {
                          image: "ships",
                          width: 32,
                          height: 32
                      }]);
                  }
              });
            </pre>

            <p>With the enemy, we will need to place them in different spots, so x &amp; y will be added to its constructor, and then passed along to the me.Entity's constructor. We pass an object hash as the settings, specifying the image as "ships", and the dimensions of the entity at 32.</p>

            <p>We used me.Entity for the base class for the enemy, because we want it to have collisions. For the player, we won't really need collisions, so we can just use a sprite.</p>

            <p>Back in play.js, add it on to the game world. Your play.js should now look like:</p>
            <pre class="brush: js">
              game.PlayScreen = me.ScreenObject.extend({
                  /**
                   *  action to perform on state change
                   */
                  onResetEvent: function() {
                      me.game.world.addChild(new me.ColorLayer("background", "#000000", 0));
                      me.game.world.addChild(new game.Player());
                      me.game.world.addChild(new game.Enemy(50, 50));
                  },


                  /**
                   *  action to perform when leaving this screen (state change)
                   */
                  onDestroyEvent: function() {
                  }
              });

            </pre>
            <p>You can put the enemy at any x &amp; y to try it out. Save &amp; refresh the page in your browser.</p>

            <p>You'll likely notice that the ship is constantly changing how it looks. If you open the ships.png file under data/img, you can see that it is a simple sprite sheet. <strong>me.Entity</strong> for its renderable uses the <strong>me.AnimationSheet</strong> class. Since we didn't add and set any animations on the renderable property, it is just looping through each &amp; every frame. Let's fix that.</p>

            <p>Add a new method to our enemy:</p>
            <pre class="brush: js">
              chooseShipImage: function () {
                  var frame = ~~(Math.random() * 3);
                  this.renderable.addAnimation("idle", [frame], 1);
                  this.renderable.setCurrentAnimation("idle");
              }
            </pre>

            <p>The first line simply randomizes which frame we want. The ship is 32x32, the image is 64x64, so we have 4 frames. ~~ is a shortcut for Math.floor when the number is 0 or positive. On negative numbers, it works like Math.ceil.</p>
            <p>The second line is accessing the animation sheet instance (this.renderable), and uses the addAnimation function to add a new idle frame. So we simply specify the index that was generated at random.</p>
            <p>With the final line, we set the current animation to idle.</p>
            <p>Call the function at the bottom of the constructor, like so:</p>
            <pre class="brush: js">
              game.Enemy = me.Entity.extend({
                  init: function (x, y) {
                      this._super(me.Entity, "init", [x, y, {
                          image: "ships",
                          width: 32,
                          height: 32
                      }]);
                      this.chooseShipImage();
                  },

                  chooseShipImage: function () {
                      var frame = ~~(Math.random() * 3);
                      this.renderable.addAnimation("idle", [frame], 1);
                      this.renderable.setCurrentAnimation("idle");
                  },
              });
            </pre>
            <p>Now refresh the page, and our ship should only pop up as one of them. Try refreshing it multiple times to see it change.</p>
          </div>

          <!-- Part 2 -->
          <a id="part2" class="offset-anchor"></a>
          <div class="subcontent">
            <h3>Applying Movement</h3>
            <p>Now that we have ships on screen, let's actually get some interaction going.</p>

            <p>Back in play.js, lets add some keybindings:</p>
          </div>



        </div> <!-- end content -->
      </div> <!-- end row -->
    </div> <!-- end container -->

    <script type="text/javascript">
      SyntaxHighlighter.all();
    </script>
  </body>
</html>
